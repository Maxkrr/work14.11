### Кривошеев Максим УИБО-14-24
# Задание №1. Вариант 20.
#### Генетический алгоритм для задачи коммивояжера. (traveling salesman's tasks.py)
Задача: реализовать генетический алгоритм для решения задачи коммивояжера.
#### Алгоритм работы:
1. Инициализация популяции: random.sample(range(n), n) создает случайную перестановку городов.
2. Вычисление длины маршрута: total_distance использует циклический расчет расстояния с помощью modulo %.
3. Order Crossover (OX): Выбираются две случайные точки сечения a и b, часть родителя parent1 копируется в потомка, оставшиеся позиции заполняются генами из parent2 в порядке их следования.
4. Мутация: swap_mutation меняет местами два случайных города.
#### Основной цикл:
1. Сортировка популяции по приспособленности (длине маршрута).
2. Элитизм: сохранение двух лучших решений.
3. Турнирный отбор: случайный выбор из 10 лучших родителей.
4. Кроссовер и мутация с вероятностью 20%.
5. Сложность одного поколения: O(pop_size * n log n) из-за сортировки.
#### Временная сложность:
Временная сложность данного кода — O(G⋅P⋅N^2), где:
1. G — количество поколений (generations),
2. P — размер популяции (pop_size),
3. N — количество городов (размер матрицы dist_matrix).
#### Объяснение временной сложности:
Временная сложность пропорциональна количеству поколений, числу маршрутов в популяции и числу городов в маршруте.
Это из-за оценки длины каждого маршрута (линейно) и операций кроссовера/мутации (также линейных) на каждом поколении.
# Задание №2. Вариант 20. 
#### Имитация отжига для задачи размещения центров. (placementofcenters.cpp)
#### Алгоритм работы:
1. Алгоритм реализует решение задачи локализации объектов (центров) для минимизации суммарного расстояния до заданных клиентов с помощью метода имитации отжига (simulated annealing).
2. Функции random_double(a, b) и random_int(a, b) генерируют случайные числа с помощью стандартной функции rand(), где rand() возвращает псевдослучайное целое число, а srand(time(0)) устанавливает начальное зерно для генератора случайных чисел, чтобы создавать разные последовательности при каждом запуске.
3. totalDistance вычисляет суммарное минимальное евклидово расстояние от каждой точки клиента до ближайшего центра.
4. sa_facility_location инициализирует k центров случайными координатами, затем в цикле при каждой итерации делает небольшое случайное изменение координаты одного из центров и рассчитывает новую стоимость (суммарное расстояние).
5. Если новая стоимость меньше текущей, изменение принимается; если больше — принимается с вероятностью exp((current_cost - new_cost)/temp) (критерий Метрополиса), что позволяет избегать локальных минимумов.
6. Температура temp постепенно уменьшается (умножением на cooling), снижая вероятность принятия ухудшающих изменений и приближая алгоритм к устойчивому решению.
7. main демонстрирует запуск алгоритма на примере точек и выводит найденные центры и финальную стоимость.
#### Временная сложность:
Временная сложность — O(m nk), где m — число итераций цикла (определяется скоростью охлаждения).
#### Объяснение временной сложности:
На каждой итерации алгоритм вычисляет расстояния от всех клиентов до всех центров, что даёт O(nk), а количество итераций зависит от параметров температурного спуска.
# Контрольный вопрос №20.
##### 5 примеров реальных приложений, где используются приближенные или эвристические алгоритмы:
1. Логистика и доставка: Amazon, яндекс.Доставка, курьерские службы
2. Рекомендательные системы: Netflix рекомендации фильмов, spotify плейлисты
3. Телекоммуникационные сети: Планирование сетей 4G/5G, размещение WiFi роутеров в больших зданиях
4. Биоинформатика и медицина: Разработка лекарств, понимание болезней (Альцгеймер, Паркинсон)
5. ИИ в играх и планирование: GPS навигаторы (A* algorithm), ИИ в стратегиях (StarCraft, Civilization)
   

